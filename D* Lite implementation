import java.util.*;

public class DStarLitePathPlanner {
    private static final char FREE_CELL = '.';
    private static final char OBSTACLE_CELL = '#';
    private static final char START_CELL = 'S';
    private static final char GOAL_CELL = 'G';
    private static final char PATH_CELL = '*';
    private static final char VISITED_CELL = 'o';
    
    private Grid grid;
    private DStarLite dstar;
    private Point start, goal;
    private Scanner scanner;
    
    public DStarLitePathPlanner() {
        this.scanner = new Scanner(System.in);
    }
    
    public void run() {
        System.out.println("=== D* Lite Algorithm Robot Path Planning ===");
        System.out.println("Commands:");
        System.out.println("1. Create new grid");
        System.out.println("2. Set start position");
        System.out.println("3. Set goal position");
        System.out.println("4. Add rectangular obstacle");
        System.out.println("5. Plan initial path");
        System.out.println("6. Move robot and replan");
        System.out.println("7. Display grid");
        System.out.println("8. Clear path");
        System.out.println("9. Exit");
        System.out.println();
        
        // Initialize with default grid
        createGrid(10, 10);
        
        while (true) {
            System.out.print("Enter command (1-9): ");
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // consume newline
                
                switch (choice) {
                    case 1:
                        createNewGrid();
                        break;
                    case 2:
                        setStartPosition();
                        break;
                    case 3:
                        setGoalPosition();
                        break;
                    case 4:
                        addObstacle();
                        break;
                    case 5:
                        planInitialPath();
                        break;
                    case 6:
                        moveRobotAndReplan();
                        break;
                    case 7:
                        displayGrid();
                        break;
                    case 8:
                        clearPath();
                        break;
                    case 9:
                        System.out.println("Goodbye!");
                        return;
                    default:
                        System.out.println("Invalid command. Please enter 1-9.");
                }
            } catch (Exception e) {
                System.out.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // consume invalid input
            }
        }
    }
    
    private void createNewGrid() {
        System.out.print("Enter grid width: ");
        int width = scanner.nextInt();
        System.out.print("Enter grid height: ");
        int height = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (width > 0 && height > 0 && width <= 50 && height <= 50) {
            createGrid(width, height);
            System.out.println("Grid created successfully!");
        } else {
            System.out.println("Invalid grid size. Please enter dimensions between 1-50.");
        }
    }
    
    private void createGrid(int width, int height) {
        this.grid = new Grid(width, height);
        this.dstar = new DStarLite(grid);
        this.start = null;
        this.goal = null;
        displayGrid();
    }
    
    private void setStartPosition() {
        System.out.print("Enter start X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter start Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (grid.isValid(x, y) && !grid.isObstacle(x, y)) {
            start = new Point(x, y);
            System.out.println("Start position set to (" + x + ", " + y + ")");
            displayGrid();
        } else {
            System.out.println("Invalid position or position is blocked by obstacle.");
        }
    }
    
    private void setGoalPosition() {
        System.out.print("Enter goal X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter goal Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (grid.isValid(x, y) && !grid.isObstacle(x, y)) {
            goal = new Point(x, y);
            System.out.println("Goal position set to (" + x + ", " + y + ")");
            displayGrid();
        } else {
            System.out.println("Invalid position or position is blocked by obstacle.");
        }
    }
    
    private void addObstacle() {
        System.out.print("Enter obstacle X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter obstacle Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        System.out.print("Enter obstacle width (1-10): ");
        int width = scanner.nextInt();
        System.out.print("Enter obstacle height (1-10): ");
        int height = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (width < 1 || width > 10 || height < 1 || height > 10) {
            System.out.println("Invalid obstacle size. Please enter width and height between 1-10.");
            return;
        }
        
        if (x + width > grid.getWidth() || y + height > grid.getHeight()) {
            System.out.println("Obstacle would extend beyond grid boundaries.");
            return;
        }
        
        boolean conflictFound = false;
        for (int dy = 0; dy < height; dy++) {
            for (int dx = 0; dx < width; dx++) {
                int nx = x + dx;
                int ny = y + dy;
                if ((start != null && start.x == nx && start.y == ny) ||
                    (goal != null && goal.x == nx && goal.y == ny)) {
                    System.out.println("Cannot place obstacle on start or goal position at (" + nx + "," + ny + ").");
                    conflictFound = true;
                }
            }
        }
        
        if (conflictFound) {
            return;
        }
        
        // Add obstacles and notify D* Lite of changes
        for (int dy = 0; dy < height; dy++) {
            for (int dx = 0; dx < width; dx++) {
                int nx = x + dx;
                int ny = y + dy;
                if (grid.isValid(nx, ny)) {
                    grid.setObstacle(nx, ny, true);
                    dstar.updateCellCost(nx, ny);
                }
            }
        }
        
        System.out.println("Rectangular obstacle (" + width + "x" + height + ") added successfully!");
        displayGrid();
        
        // If robot is initialized, replan automatically
        if (start != null && goal != null && dstar.isInitialized()) {
            System.out.println("Replanning path due to new obstacle...");
            dstar.replan();
            displayGrid();
        }
    }
    
    private void planInitialPath() {
        if (start == null || goal == null) {
            System.out.println("Please set both start and goal positions first.");
            return;
        }
        
        System.out.println("Planning initial path...");
        long startTime = System.currentTimeMillis();
        
        boolean pathExists = dstar.initialize(start, goal);
        
        long endTime = System.currentTimeMillis();
        
        if (!pathExists) {
            System.out.println("No path found between start and goal!");
        } else {
            System.out.println("Initial path found!");
            System.out.println("Planning time: " + (endTime - startTime) + " ms");
            System.out.println("Nodes expanded: " + dstar.getNodesExpanded());
            
            List<Point> path = dstar.getPath();
            System.out.print("Path: ");
            for (int i = 0; i < path.size(); i++) {
                Point p = path.get(i);
                System.out.print("(" + p.x + "," + p.y + ")");
                if (i < path.size() - 1) System.out.print(" -> ");
            }
            System.out.println();
        }
        
        displayGrid();
    }
    
    private void moveRobotAndReplan() {
        if (!dstar.isInitialized()) {
            System.out.println("Please plan initial path first.");
            return;
        }
        
        System.out.print("Enter new robot X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter new robot Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (grid.isValid(x, y) && !grid.isObstacle(x, y)) {
            start = new Point(x, y);
            System.out.println("Robot moved to (" + x + ", " + y + ")");
            
            long startTime = System.currentTimeMillis();
            boolean pathExists = dstar.updateStart(start);
            long endTime = System.currentTimeMillis();
            
            if (!pathExists) {
                System.out.println("No path found from new position!");
            } else {
                System.out.println("Path replanned!");
                System.out.println("Replanning time: " + (endTime - startTime) + " ms");
                System.out.println("Additional nodes expanded: " + dstar.getLastReplanExpansions());
                
                List<Point> path = dstar.getPath();
                System.out.print("New path: ");
                for (int i = 0; i < path.size(); i++) {
                    Point p = path.get(i);
                    System.out.print("(" + p.x + "," + p.y + ")");
                    if (i < path.size() - 1) System.out.print(" -> ");
                }
                System.out.println();
            }
            
            displayGrid();
        } else {
            System.out.println("Invalid position or position is blocked by obstacle.");
        }
    }
    
    private void clearPath() {
        if (dstar != null) {
            dstar.clear();
            System.out.println("Path cleared!");
            displayGrid();
        }
    }
    
    private void displayGrid() {
        System.out.println("\n=== Grid Display ===");
        System.out.println("Legend: . = free, # = obstacle, S = start, G = goal, * = path, o = visited");
        
        // Print column numbers
        System.out.print("   ");
        for (int x = 0; x < grid.getWidth(); x++) {
            System.out.printf("%2d ", x);
        }
        System.out.println();
        
        // Print grid with row numbers
        for (int y = 0; y < grid.getHeight(); y++) {
            System.out.printf("%2d ", y);
            for (int x = 0; x < grid.getWidth(); x++) {
                char cell = getCellDisplay(x, y);
                System.out.print(" " + cell + " ");
            }
            System.out.println();
        }
        System.out.println();
    }
    
    private char getCellDisplay(int x, int y) {
        if (grid.isObstacle(x, y)) {
            return OBSTACLE_CELL;
        } else if (start != null && start.x == x && start.y == y) {
            return START_CELL;
        } else if (goal != null && goal.x == x && goal.y == y) {
            return GOAL_CELL;
        } else if (dstar.isOnPath(x, y)) {
            return PATH_CELL;
        } else if (dstar.isVisited(x, y)) {
            return VISITED_CELL;
        } else {
            return FREE_CELL;
        }
    }
    
    public static void main(String[] args) {
        new DStarLitePathPlanner().run();
    }
}

// Point class for coordinates
class Point {
    public final int x, y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Point point = (Point) obj;
        return x == point.x && y == point.y;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
    
    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}

// Grid class representing the environment
class Grid {
    private final int width, height;
    private final boolean[][] obstacles;
    
    public Grid(int width, int height) {
        this.width = width;
        this.height = height;
        this.obstacles = new boolean[width][height];
    }
    
    public boolean isObstacle(int x, int y) {
        return isValid(x, y) && obstacles[x][y];
    }
    
    public void setObstacle(int x, int y, boolean isObstacle) {
        if (isValid(x, y)) {
            obstacles[x][y] = isObstacle;
        }
    }
    
    public boolean isValid(int x, int y) {
        return x >= 0 && x < width && y >= 0 && y < height;
    }
    
    public int getWidth() { return width; }
    public int getHeight() { return height; }
    
    public double getCost(int x1, int y1, int x2, int y2) {
        if (!isValid(x1, y1) || !isValid(x2, y2) || isObstacle(x2, y2)) {
            return Double.POSITIVE_INFINITY;
        }
        
        // Euclidean distance
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
}

// D* Lite Node
class DStarNode {
    public final int x, y;
    public double g, rhs;
    public boolean visited;
    
    public DStarNode(int x, int y) {
        this.x = x;
        this.y = y;
        this.g = Double.POSITIVE_INFINITY;
        this.rhs = Double.POSITIVE_INFINITY;
        this.visited = false;
    }
    
    public double getDistance(DStarNode other) {
        return Math.sqrt(Math.pow(x - other.x, 2) + Math.pow(y - other.y, 2));
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        DStarNode node = (DStarNode) obj;
        return x == node.x && y == node.y;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
    
    @Override
    public String toString() {
        return "DStarNode(" + x + ", " + y + ")";
    }
}

// Key for priority queue
class Key implements Comparable<Key> {
    public final double k1, k2;
    
    public Key(double k1, double k2) {
        this.k1 = k1;
        this.k2 = k2;
    }
    
    @Override
    public int compareTo(Key other) {
        if (Math.abs(k1 - other.k1) < 1e-9) {
            return Double.compare(k2, other.k2);
        }
        return Double.compare(k1, other.k1);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Key key = (Key) obj;
        return Math.abs(k1 - key.k1) < 1e-9 && Math.abs(k2 - key.k2) < 1e-9;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(k1, k2);
    }
}

// D* Lite Algorithm implementation
class DStarLite {
    private final Grid grid;
    private final Map<String, DStarNode> nodes;
    private final PriorityQueue<DStarNode> U; // Priority queue
    private final Map<DStarNode, Key> priorities;
    private DStarNode sStart, sGoal;
    private double km;
    private int nodesExpanded;
    private int lastReplanExpansions;
    private boolean initialized;
    
    // Directions for 8-connected grid
    private final int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
    private final int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};
    
    public DStarLite(Grid grid) {
        this.grid = grid;
        this.nodes = new HashMap<>();
        this.U = new PriorityQueue<>((a, b) -> {
            Key ka = calculateKey(a);
            Key kb = calculateKey(b);
            return ka.compareTo(kb);
        });
        this.priorities = new HashMap<>();
        this.km = 0;
        this.nodesExpanded = 0;
        this.lastReplanExpansions = 0;
        this.initialized = false;
    }
    
    public boolean initialize(Point start, Point goal) {
        // Clear previous state
        clear();
        
        sStart = getNode(start.x, start.y);
        sGoal = getNode(goal.x, goal.y);
        
        // Initialize goal
        sGoal.rhs = 0;
        U.add(sGoal);
        priorities.put(sGoal, calculateKey(sGoal));
        
        // Run initial search
        boolean pathExists = computeShortestPath();
        initialized = pathExists;
        
        return pathExists;
    }
    
    public boolean updateStart(Point newStart) {
        if (!initialized) {
            return false;
        }
        
        sStart = getNode(newStart.x, newStart.y);
        lastReplanExpansions = 0;
        
        return computeShortestPath();
    }
    
    public void updateCellCost(int x, int y) {
        if (!initialized) {
            return;
        }
        
        DStarNode u = getNode(x, y);
        if (u != sGoal) {
            updateVertex(u);
        }
        
        // Update all neighbors
        for (int i = 0; i < 8; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if (grid.isValid(nx, ny)) {
                DStarNode neighbor = getNode(nx, ny);
                if (neighbor != sGoal) {
                    updateVertex(neighbor);
                }
            }
        }
    }
    
    public void replan() {
        if (!initialized) {
            return;
        }
        
        lastReplanExpansions = 0;
        computeShortestPath();
    }
    
    private boolean computeShortestPath() {
        while (!U.isEmpty() && 
               (U.peek() != null && calculateKey(U.peek()).compareTo(calculateKey(sStart)) < 0) ||
               sStart.rhs != sStart.g) {
            
            DStarNode u = U.poll();
            priorities.remove(u);
            u.visited = true;
            nodesExpanded++;
            lastReplanExpansions++;
            
            Key kOld = calculateKey(u);
            Key kNew = calculateKey(u);
            
            if (kOld.compareTo(kNew) < 0) {
                U.add(u);
                priorities.put(u, kNew);
            } else if (u.g > u.rhs) {
                u.g = u.rhs;
                for (DStarNode s : getPredecessors(u)) {
                    if (s != sGoal) {
                        updateVertex(s);
                    }
                }
            } else {
                u.g = Double.POSITIVE_INFINITY;
                for (DStarNode s : getPredecessors(u)) {
                    if (s != sGoal) {
                        updateVertex(s);
                    }
                }
                if (u != sGoal) {
                    updateVertex(u);
                }
            }
        }
        
        return sStart.g != Double.POSITIVE_INFINITY;
    }
    
    private void updateVertex(DStarNode u) {
        if (u != sGoal) {
            u.rhs = Double.POSITIVE_INFINITY;
            for (DStarNode s : getSuccessors(u)) {
                double cost = grid.getCost(u.x, u.y, s.x, s.y);
                if (cost != Double.POSITIVE_INFINITY) {
                    u.rhs = Math.min(u.rhs, s.g + cost);
                }
            }
        }
        
        // Remove from priority queue if present
        if (U.contains(u)) {
            U.remove(u);
            priorities.remove(u);
        }
        
        // Add to priority queue if locally inconsistent
        if (u.g != u.rhs) {
            U.add(u);
            priorities.put(u, calculateKey(u));
        }
    }
    
    private Key calculateKey(DStarNode s) {
        double k1 = Math.min(s.g, s.rhs) + getHeuristic(sStart, s) + km;
        double k2 = Math.min(s.g, s.rhs);
        return new Key(k1, k2);
    }
    
    private double getHeuristic(DStarNode a, DStarNode b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }
    
    private List<DStarNode> getSuccessors(DStarNode node) {
        List<DStarNode> successors = new ArrayList<>();
        for (int i = 0; i < 8; i++) {
            int nx = node.x + dx[i];
            int ny = node.y + dy[i];
            if (grid.isValid(nx, ny)) {
                successors.add(getNode(nx, ny));
            }
        }
        return successors;
    }
    
    private List<DStarNode> getPredecessors(DStarNode node) {
        // In a grid, predecessors are the same as successors
        return getSuccessors(node);
    }
    
    private DStarNode getNode(int x, int y) {
        String key = x + "," + y;
        return nodes.computeIfAbsent(key, k -> new DStarNode(x, y));
    }
    
    public List<Point> getPath() {
        if (!initialized || sStart.g == Double.POSITIVE_INFINITY) {
            return new ArrayList<>();
        }
        
        List<Point> path = new ArrayList<>();
        DStarNode current = sStart;
        path.add(new Point(current.x, current.y));
        
        while (!current.equals(sGoal)) {
            DStarNode next = null;
            double minCost = Double.POSITIVE_INFINITY;
            
            for (DStarNode successor : getSuccessors(current)) {
                double cost = grid.getCost(current.x, current.y, successor.x, successor.y);
                if (cost != Double.POSITIVE_INFINITY) {
                    double totalCost = cost + successor.g;
                    if (totalCost < minCost) {
                        minCost = totalCost;
                        next = successor;
                    }
                }
            }
            
            if (next == null) {
                break; // No path found
            }
            
            current = next;
            path.add(new Point(current.x, current.y));
        }
        
        return path;
    }
    
    public boolean isOnPath(int x, int y) {
        List<Point> path = getPath();
        return path.stream().anyMatch(p -> p.x == x && p.y == y);
    }
    
    public boolean isVisited(int x, int y) {
        DStarNode node = nodes.get(x + "," + y);
        return node != null && node.visited;
    }
    
    public void clear() {
        U.clear();
        priorities.clear();
        nodes.clear();
        km = 0;
        nodesExpanded = 0;
        lastReplanExpansions = 0;
        initialized = false;
    }
    
    public int getNodesExpanded() { return nodesExpanded; }
    public int getLastReplanExpansions() { return lastReplanExpansions; }
    public boolean isInitialized() { return initialized; }
}
