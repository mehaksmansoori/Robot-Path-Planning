import java.util.*;

public class DStarLitePathPlanner {
    private static final char FREE_CELL = '.';
    private static final char OBSTACLE_CELL = '#';
    private static final char START_CELL = 'S';
    private static final char GOAL_CELL = 'G';
    private static final char PATH_CELL = '*';
    private static final char VISITED_CELL = 'o';
    
    private Grid grid;
    private DStarLite dstar;
    private Point start, goal;
    private Scanner scanner;
    
    public DStarLitePathPlanner() {
        this.scanner = new Scanner(System.in);
    }
    
    public void run() {
        System.out.println("=== D* Lite Algorithm Robot Path Planning ===");
        System.out.println("Commands:");
        System.out.println("1. Create new grid");
        System.out.println("2. Set start position");
        System.out.println("3. Set goal position");
        System.out.println("4. Add rectangular obstacle");
        System.out.println("5. Plan initial path");
        System.out.println("6. Move robot and replan");
        System.out.println("7. Display grid");
        System.out.println("8. Clear path");
        System.out.println("9. Debug info");
        System.out.println("0. Exit");
        System.out.println();
        
        // Ask user for initial grid size instead of defaulting
        System.out.println("Let's start by creating your grid:");
        createNewGrid();
        
        while (true) {
            System.out.print("Enter command (0-9): ");
            try {
                int choice = scanner.nextInt();
                scanner.nextLine(); // consume newline
                
                switch (choice) {
                    case 1:
                        createNewGrid();
                        break;
                    case 2:
                        setStartPosition();
                        break;
                    case 3:
                        setGoalPosition();
                        break;
                    case 4:
                        addObstacle();
                        break;
                    case 5:
                        planInitialPath();
                        break;
                    case 6:
                        moveRobotAndReplan();
                        break;
                    case 7:
                        displayGrid();
                        break;
                    case 8:
                        clearPath();
                        break;
                    case 9:
                        if (dstar != null) {
                            dstar.printDebugInfo();
                        } else {
                            System.out.println("No D* Lite instance available.");
                        }
                        break;
                    case 0:
                        System.out.println("Goodbye!");
                        return;
                    default:
                        System.out.println("Invalid command. Please enter 0-9.");
                }
            } catch (Exception e) {
                System.out.println("Invalid input. Please enter a number.");
                scanner.nextLine(); // consume invalid input
            }
        }
    }
    
    private void createNewGrid() {
        System.out.println("\n=== Create New Grid ===");
        System.out.println("Grid size limits: 1-50 for both width and height");
        System.out.println("Recommended sizes: 10x10 for testing, 20x20 for medium complexity");
        
        int width = 0, height = 0;
        boolean validInput = false;
        
        // Get width with validation
        while (!validInput) {
            try {
                System.out.print("Enter grid width (1-50): ");
                width = scanner.nextInt();
                if (width >= 1 && width <= 50) {
                    validInput = true;
                } else {
                    System.out.println("Width must be between 1 and 50.");
                }
            } catch (Exception e) {
                System.out.println("Please enter a valid number.");
                scanner.nextLine(); // consume invalid input
            }
        }
        
        validInput = false;
        // Get height with validation
        while (!validInput) {
            try {
                System.out.print("Enter grid height (1-50): ");
                height = scanner.nextInt();
                if (height >= 1 && height <= 50) {
                    validInput = true;
                } else {
                    System.out.println("Height must be between 1 and 50.");
                }
            } catch (Exception e) {
                System.out.println("Please enter a valid number.");
                scanner.nextLine(); // consume invalid input
            }
        }
        scanner.nextLine(); // consume newline
        
        // Confirm large grids
        if (width * height > 400) {
            System.out.print("Large grid (" + width + "x" + height + ") detected. This may impact display readability. Continue? (y/n): ");
            String confirm = scanner.nextLine().toLowerCase();
            if (!confirm.startsWith("y")) {
                System.out.println("Grid creation cancelled.");
                return;
            }
        }
        
        createGrid(width, height);
        System.out.println("Grid (" + width + "x" + height + ") created successfully!");
    }
    
    private void createGrid(int width, int height) {
        this.grid = new Grid(width, height);
        this.dstar = new DStarLite(grid);
        this.start = null;
        this.goal = null;
        displayGrid();
    }
    
    private void setStartPosition() {
        if (grid == null) {
            System.out.println("Please create a grid first.");
            return;
        }
        
        System.out.print("Enter start X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter start Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (grid.isValid(x, y) && !grid.isObstacle(x, y)) {
            start = new Point(x, y);
            System.out.println("Start position set to (" + x + ", " + y + ")");
            displayGrid();
        } else {
            System.out.println("Invalid position or position is blocked by obstacle.");
        }
    }
    
    private void setGoalPosition() {
        if (grid == null) {
            System.out.println("Please create a grid first.");
            return;
        }
        
        System.out.print("Enter goal X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter goal Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (grid.isValid(x, y) && !grid.isObstacle(x, y)) {
            goal = new Point(x, y);
            System.out.println("Goal position set to (" + x + ", " + y + ")");
            displayGrid();
        } else {
            System.out.println("Invalid position or position is blocked by obstacle.");
        }
    }
    
    private void addObstacle() {
        if (grid == null) {
            System.out.println("Please create a grid first.");
            return;
        }
        
        System.out.print("Enter obstacle X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter obstacle Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        System.out.print("Enter obstacle width (1-10): ");
        int width = scanner.nextInt();
        System.out.print("Enter obstacle height (1-10): ");
        int height = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (width < 1 || width > 10 || height < 1 || height > 10) {
            System.out.println("Invalid obstacle size. Please enter width and height between 1-10.");
            return;
        }
        
        if (x + width > grid.getWidth() || y + height > grid.getHeight()) {
            System.out.println("Obstacle would extend beyond grid boundaries.");
            return;
        }
        
        boolean conflictFound = false;
        for (int dy = 0; dy < height; dy++) {
            for (int dx = 0; dx < width; dx++) {
                int nx = x + dx;
                int ny = y + dy;
                if ((start != null && start.x == nx && start.y == ny) ||
                    (goal != null && goal.x == nx && goal.y == ny)) {
                    System.out.println("Cannot place obstacle on start or goal position at (" + nx + "," + ny + ").");
                    conflictFound = true;
                }
            }
        }
        
        if (conflictFound) {
            return;
        }
        
        // Add obstacles and notify D* Lite of changes
        for (int dy = 0; dy < height; dy++) {
            for (int dx = 0; dx < width; dx++) {
                int nx = x + dx;
                int ny = y + dy;
                if (grid.isValid(nx, ny)) {
                    grid.setObstacle(nx, ny, true);
                    dstar.updateCellCost(nx, ny);
                }
            }
        }
        
        System.out.println("Rectangular obstacle (" + width + "x" + height + ") added successfully!");
        displayGrid();
        
        // If robot is initialized, replan automatically
        if (start != null && goal != null && dstar.isInitialized()) {
            System.out.println("Replanning path due to new obstacle...");
            dstar.replan();
            displayGrid();
        }
    }
    
    private void planInitialPath() {
        if (grid == null) {
            System.out.println("Please create a grid first.");
            return;
        }
        
        if (start == null || goal == null) {
            System.out.println("Please set both start and goal positions first.");
            return;
        }
        
        System.out.println("Planning initial path...");
        long startTime = System.currentTimeMillis();
        
        boolean pathExists = dstar.initialize(start, goal);
        
        long endTime = System.currentTimeMillis();
        
        if (!pathExists) {
            System.out.println("No path found between start and goal!");
        } else {
            System.out.println("Initial path found!");
            System.out.println("Planning time: " + (endTime - startTime) + " ms");
            System.out.println("Nodes expanded: " + dstar.getNodesExpanded());
            
            List<Point> path = dstar.getPath();
            System.out.print("Path: ");
            for (int i = 0; i < path.size(); i++) {
                Point p = path.get(i);
                System.out.print("(" + p.x + "," + p.y + ")");
                if (i < path.size() - 1) System.out.print(" -> ");
            }
            System.out.println();
        }
        
        displayGrid();
    }
    
    private void moveRobotAndReplan() {
        if (grid == null) {
            System.out.println("Please create a grid first.");
            return;
        }
        
        if (!dstar.isInitialized()) {
            System.out.println("Please plan initial path first.");
            return;
        }
        
        System.out.print("Enter new robot X coordinate (0-" + (grid.getWidth()-1) + "): ");
        int x = scanner.nextInt();
        System.out.print("Enter new robot Y coordinate (0-" + (grid.getHeight()-1) + "): ");
        int y = scanner.nextInt();
        scanner.nextLine(); // consume newline
        
        if (grid.isValid(x, y) && !grid.isObstacle(x, y)) {
            start = new Point(x, y);
            System.out.println("Robot moved to (" + x + ", " + y + ")");
            
            long startTime = System.currentTimeMillis();
            boolean pathExists = dstar.updateStart(start);
            long endTime = System.currentTimeMillis();
            
            if (!pathExists) {
                System.out.println("No path found from new position!");
            } else {
                System.out.println("Path replanned!");
                System.out.println("Replanning time: " + (endTime - startTime) + " ms");
                System.out.println("Additional nodes expanded: " + dstar.getLastReplanExpansions());
                
                List<Point> path = dstar.getPath();
                System.out.print("New path: ");
                for (int i = 0; i < path.size(); i++) {
                    Point p = path.get(i);
                    System.out.print("(" + p.x + "," + p.y + ")");
                    if (i < path.size() - 1) System.out.print(" -> ");
                }
                System.out.println();
            }
            
            displayGrid();
        } else {
            System.out.println("Invalid position or position is blocked by obstacle.");
        }
    }
    
    private void clearPath() {
        if (dstar != null) {
            dstar.clear();
            System.out.println("Path cleared!");
            displayGrid();
        }
    }
    
    private void displayGrid() {
        if (grid == null) {
            System.out.println("No grid created yet.");
            return;
        }
        
        System.out.println("\n=== Grid Display (" + grid.getWidth() + "x" + grid.getHeight() + ") ===");
        System.out.println("Legend: . = free, # = obstacle, S = start, G = goal, * = path, o = visited");
        
        // For large grids, consider condensed display
        if (grid.getWidth() > 30 || grid.getHeight() > 30) {
            System.out.println("(Large grid - display may be condensed)");
        }
        
        // Print column numbers
        System.out.print("   ");
        for (int x = 0; x < grid.getWidth(); x++) {
            if (grid.getWidth() > 30) {
                System.out.print(x % 10); // Single digit for large grids
            } else {
                System.out.printf("%2d ", x);
            }
        }
        System.out.println();
        
        // Print grid with row numbers
        for (int y = 0; y < grid.getHeight(); y++) {
            if (grid.getWidth() > 30) {
                System.out.printf("%2d ", y);
            } else {
                System.out.printf("%2d ", y);
            }
            
            for (int x = 0; x < grid.getWidth(); x++) {
                char cell = getCellDisplay(x, y);
                if (grid.getWidth() > 30) {
                    System.out.print(cell); // Condensed for large grids
                } else {
                    System.out.print(" " + cell + " ");
                }
            }
            System.out.println();
        }
        System.out.println();
    }
    
    private char getCellDisplay(int x, int y) {
        if (grid.isObstacle(x, y)) {
            return OBSTACLE_CELL;
        } else if (start != null && start.x == x && start.y == y) {
            return START_CELL;
        } else if (goal != null && goal.x == x && goal.y == y) {
            return GOAL_CELL;
        } else if (dstar.isOnPath(x, y)) {
            return PATH_CELL;
        } else if (dstar.isVisited(x, y)) {
            return VISITED_CELL;
        } else {
            return FREE_CELL;
        }
    }
    
    public static void main(String[] args) {
        new DStarLitePathPlanner().run();
    }
}

// Point class for coordinates
class Point {
    public final int x, y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Point point = (Point) obj;
        return x == point.x && y == point.y;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
    
    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}

// Grid class representing the environment
class Grid {
    private final int width, height;
    private final boolean[][] obstacles;
    
    public Grid(int width, int height) {
        this.width = width;
        this.height = height;
        this.obstacles = new boolean[width][height];
    }
    
    public boolean isObstacle(int x, int y) {
        return isValid(x, y) && obstacles[x][y];
    }
    
    public void setObstacle(int x, int y, boolean isObstacle) {
        if (isValid(x, y)) {
            obstacles[x][y] = isObstacle;
        }
    }
    
    public boolean isValid(int x, int y) {
        return x >= 0 && x < width && y >= 0 && y < height;
    }
    
    public int getWidth() { return width; }
    public int getHeight() { return height; }
    
    public double getCost(int x1, int y1, int x2, int y2) {
        if (!isValid(x1, y1) || !isValid(x2, y2)) {
            return Double.POSITIVE_INFINITY;
        }
        
        if (isObstacle(x2, y2)) {
            return Double.POSITIVE_INFINITY;
        }
        
        // Check if we're trying to move through a diagonal with obstacles
        if (x1 != x2 && y1 != y2) {
            // Diagonal movement - check if path is blocked
            if (isObstacle(x1, y2) && isObstacle(x2, y1)) {
                return Double.POSITIVE_INFINITY; // Both diagonal neighbors blocked
            }
            
            // Optional: Add penalty for diagonal movement through tight spaces
            if (isObstacle(x1, y2) || isObstacle(x2, y1)) {
                return Math.sqrt(2) * 1.1; // Slight penalty for risky diagonal
            }
        }
        
        // Calculate distance-based cost
        double dx = x2 - x1;
        double dy = y2 - y1;
        double distance = Math.sqrt(dx * dx + dy * dy);
        
        // Add terrain-based cost modifiers (can be extended)
        double terrainCost = 1.0;
        
        // Example: add small cost variation based on position (simulating terrain)
        terrainCost += 0.1 * Math.sin(x2 * 0.1) * Math.cos(y2 * 0.1);
        terrainCost = Math.max(0.5, Math.min(2.0, terrainCost)); // Clamp between 0.5 and 2.0
        
        return distance * terrainCost;
    }
}

// D* Lite Node
class DStarNode {
    public final int x, y;
    public double g, rhs;
    public boolean visited;
    
    public DStarNode(int x, int y) {
        this.x = x;
        this.y = y;
        this.g = Double.POSITIVE_INFINITY;
        this.rhs = Double.POSITIVE_INFINITY;
        this.visited = false;
    }
    
    public double getDistance(DStarNode other) {
        return Math.sqrt(Math.pow(x - other.x, 2) + Math.pow(y - other.y, 2));
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        DStarNode node = (DStarNode) obj;
        return x == node.x && y == node.y;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
    
    @Override
    public String toString() {
        return "DStarNode(" + x + ", " + y + ")";
    }
}

// Key for priority queue
class Key implements Comparable<Key> {
    public final double k1, k2;
    
    public Key(double k1, double k2) {
        this.k1 = k1;
        this.k2 = k2;
    }
    
    @Override
    public int compareTo(Key other) {
        if (Math.abs(k1 - other.k1) < 1e-9) {
            return Double.compare(k2, other.k2);
        }
        return Double.compare(k1, other.k1);
    }
    
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Key key = (Key) obj;
        return Math.abs(k1 - key.k1) < 1e-9 && Math.abs(k2 - key.k2) < 1e-9;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(k1, k2);
    }
}

// D* Lite Algorithm implementation
class DStarLite {
    private final Grid grid;
    private final Map<String, DStarNode> nodes;
    private final PriorityQueue<DStarNode> U; // Priority queue
    private final Map<DStarNode, Key> priorities;
    private DStarNode sStart, sGoal;
    private double km;
    private int nodesExpanded;
    private int lastReplanExpansions;
    private boolean initialized;
    
    // Directions for 8-connected grid
    private final int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
    private final int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};
    
    public DStarLite(Grid grid) {
        this.grid = grid;
        this.nodes = new HashMap<>();
        this.U = new PriorityQueue<>((a, b) -> {
            Key ka = calculateKey(a);
            Key kb = calculateKey(b);
            return ka.compareTo(kb);
        });
        this.priorities = new HashMap<>();
        this.km = 0;
        this.nodesExpanded = 0;
        this.lastReplanExpansions = 0;
        this.initialized = false;
    }
    
    public boolean initialize(Point start, Point goal) {
        // Clear previous state
        clear();
        
        sStart = getNode(start.x, start.y);
        sGoal = getNode(goal.x, goal.y);
        
        // Initialize goal
        sGoal.rhs = 0;
        U.add(sGoal);
        priorities.put(sGoal, calculateKey(sGoal));
        
        // Run initial search
        boolean pathExists = computeShortestPath();
        initialized = pathExists;
        
        return pathExists;
    }
    
    public boolean updateStart(Point newStart) {
        if (!initialized) {
            return false;
        }
        
        DStarNode sLast = sStart;
        sStart = getNode(newStart.x, newStart.y);
        lastReplanExpansions = 0;
        
        // Update km with heuristic difference (key insight of D* Lite)
        if (sLast != null) {
            km += getHeuristic(sLast, sStart);
        }
        
        return computeShortestPath();
    }
    
    public void updateCellCost(int x, int y) {
        if (!initialized) {
            return;
        }
        
        DStarNode u = getNode(x, y);
        
        // Store old costs for comparison
        Map<DStarNode, Double> oldCosts = new HashMap<>();
        for (DStarNode neighbor : getSuccessors(u)) {
            oldCosts.put(neighbor, grid.getCost(u.x, u.y, neighbor.x, neighbor.y));
        }
        
        // Update the cell and check for cost changes
        boolean costsChanged = false;
        for (DStarNode neighbor : getSuccessors(u)) {
            double newCost = grid.getCost(u.x, u.y, neighbor.x, neighbor.y);
            double oldCost = oldCosts.get(neighbor);
            if (Math.abs(newCost - oldCost) > 1e-9) {
                costsChanged = true;
                break;
            }
        }
        
        // Only update if costs actually changed
        if (costsChanged) {
            // Update the node itself
            if (u != sGoal) {
                updateVertex(u);
            }
            
            // Update all neighbors that might be affected
            for (DStarNode neighbor : getSuccessors(u)) {
                if (neighbor != sGoal) {
                    updateVertex(neighbor);
                }
            }
            
            // Also update predecessors (nodes that can reach this cell)
            for (DStarNode predecessor : getPredecessors(u)) {
                if (predecessor != sGoal) {
                    updateVertex(predecessor);
                }
            }
        }
    }
    
    public void replan() {
        if (!initialized) {
            return;
        }
        
        lastReplanExpansions = 0;
        
        // Update km based on heuristic change (important for optimality)
        if (sStart != null) {
            km += getHeuristic(sStart, sGoal);
        }
        
        computeShortestPath();
    }
    
    private boolean computeShortestPath() {
        int iterations = 0;
        final int MAX_ITERATIONS = grid.getWidth() * grid.getHeight() * 10; // Prevent infinite loops
        
        while (!U.isEmpty() && iterations < MAX_ITERATIONS) {
            Key topKey = calculateKey(U.peek());
            Key startKey = calculateKey(sStart);
            
            if (topKey.compareTo(startKey) >= 0 && sStart.rhs == sStart.g) {
                break; // Optimal path found
            }
            
            DStarNode u = U.poll();
            priorities.remove(u);
            u.visited = true;
            nodesExpanded++;
            lastReplanExpansions++;
            iterations++;
            
            Key kOld = priorities.get(u);
            Key kNew = calculateKey(u);
            
            if (kOld != null && kOld.compareTo(kNew) < 0) {
                // Key has improved, reinsert with new key
                U.add(u);
                priorities.put(u, kNew);
            } else if (u.g > u.rhs) {
                // Overconsistent node - make consistent
                u.g = u.rhs;
                for (DStarNode s : getPredecessors(u)) {
                    if (s != sGoal) {
                        updateVertex(s);
                    }
                }
            } else {
                // Underconsistent node - make overconsistent and update
                u.g = Double.POSITIVE_INFINITY;
                
                // Update predecessors
                for (DStarNode s : getPredecessors(u)) {
                    if (s != sGoal) {
                        updateVertex(s);
                    }
                }
                
                // Update the node itself
                if (u != sGoal) {
                    updateVertex(u);
                }
            }
        }
        
        if (iterations >= MAX_ITERATIONS) {
            System.err.println("Warning: computeShortestPath reached maximum iterations");
        }
        
        return sStart.g != Double.POSITIVE_INFINITY;
    }
    
    private void updateVertex(DStarNode u) {
        if (u != sGoal) {
            // Calculate new rhs value
            double newRhs = Double.POSITIVE_INFINITY;
            for (DStarNode s : getSuccessors(u)) {
                double cost = grid.getCost(u.x, u.y, s.x, s.y);
                if (cost != Double.POSITIVE_INFINITY) {
                    newRhs = Math.min(newRhs, s.g + cost);
                }
            }
            u.rhs = newRhs;
        }
        
        // Remove from priority queue if present
        if (U.contains(u)) {
            U.remove(u);
            priorities.remove(u);
        }
        
        // Add to priority queue if locally inconsistent
        if (Math.abs(u.g - u.rhs) > 1e-9) { // Use epsilon for floating point comparison
            Key newKey = calculateKey(u);
            U.add(u);
            priorities.put(u, newKey);
        }
    }
    
    private Key calculateKey(DStarNode s) {
        double k1 = Math.min(s.g, s.rhs) + getHeuristic(sStart, s) + km;
        double k2 = Math.min(s.g, s.rhs);
        return new Key(k1, k2);
    }
    
    private double getHeuristic(DStarNode a, DStarNode b) {
        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
    }
    
    private List<DStarNode> getSuccessors(DStarNode node) {
        List<DStarNode> successors = new ArrayList<>();
        for (int i = 0; i < 8; i++) {
            int nx = node.x + dx[i];
            int ny = node.y + dy[i];
            if (grid.isValid(nx, ny)) {
                successors.add(getNode(nx, ny));
            }
        }
        return successors;
    }
    
    private List<DStarNode> getPredecessors(DStarNode node) {
        // In a grid, predecessors are the same as successors
        return getSuccessors(node);
    }
    
    private DStarNode getNode(int x, int y) {
        String key = x + "," + y;
        return nodes.computeIfAbsent(key, k -> new DStarNode(x, y));
    }
    
    public List<Point> getPath() {
        if (!initialized || sStart.g == Double.POSITIVE_INFINITY) {
            return new ArrayList<>();
        }
        
        List<Point> path = new ArrayList<>();
        DStarNode current = sStart;
        path.add(new Point(current.x, current.y));
        
        while (!current.equals(sGoal)) {
            DStarNode next = null;
            double minCost = Double.POSITIVE_INFINITY;
            
            for (DStarNode successor : getSuccessors(current)) {
                double cost = grid.getCost(current.x, current.y, successor.x, successor.y);
                if (cost != Double.POSITIVE_INFINITY) {
                    double totalCost = cost + successor.g;
                    if (totalCost < minCost) {
                        minCost = totalCost;
                        next = successor;
                    }
                }
            }
            
            if (next == null) {
                break; // No path found
            }
            
            current = next;
            path.add(new Point(current.x, current.y));
        }
        
        return path;
    }
    
    public boolean isOnPath(int x, int y) {
        List<Point> path = getPath();
        return path.stream().anyMatch(p -> p.x == x && p.y == y);
    }
    
    public boolean isVisited(int x, int y) {
        DStarNode node = nodes.get(x + "," + y);
        return node != null && node.visited;
    }
    
    public void clear() {
        U.clear();
        priorities.clear();
        nodes.clear();
        km = 0;
        nodesExpanded = 0;
        lastReplanExpansions = 0;
        initialized = false;
    }
    
    // Additional utility methods
    public double getKm() { return km; }
    public int getNodesExpanded() { return nodesExpanded; }
    public int getLastReplanExpansions() { return lastReplanExpansions; }
    public boolean isInitialized() { return initialized; }
    
    public void printDebugInfo() {
        System.out.println("=== D* Lite Debug Info ===");
        System.out.println("km value: " + km);
        System.out.println("Priority queue size: " + U.size());
        System.out.println("Total nodes created: " + nodes.size());
        System.out.println("Nodes expanded: " + nodesExpanded);
        System.out.println("Last replan expansions: " + lastReplanExpansions);
        System.out.println("Initialized: " + initialized);
        if (sStart != null) {
            System.out.println("Start node g=" + sStart.g + ", rhs=" + sStart.rhs);
        }
        if (sGoal != null) {
            System.out.println("Goal node g=" + sGoal.g + ", rhs=" + sGoal.rhs);
        }
        System.out.println("========================");
    }
}
