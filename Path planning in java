import java.util.*;

/**
 * D* (Dynamic A-Star) Pathfinding Algorithm Implementation
 * For robot navigation in a 2D grid environment with dynamic obstacle discovery
 */
public class DStarPathfinder {
    
    // Grid dimensions (1000x1000 for 1km x 1km area with 1m resolution)
    private static final int GRID_SIZE = 1000;
    private static final double SQRT2 = Math.sqrt(2);
    
    // Grid representation
    private boolean[][] obstacles;
    private boolean[][] knownObstacles;
    private Node[][] nodes;
    
    // D* specific data structures
    private PriorityQueue<Node> openList;
    private Set<Node> closedList;
    private Point start, goal;
    private Point currentPosition;
    
    // Node class for D* algorithm
    private static class Node implements Comparable<Node> {
        int x, y;
        double g; // Cost from start
        double rhs; // Right-hand side value (one-step lookahead)
        double h; // Heuristic to goal
        double key1, key2; // Priority queue keys
        Node parent;
        boolean inOpenList;
        
        Node(int x, int y) {
            this.x = x;
            this.y = y;
            this.g = Double.POSITIVE_INFINITY;
            this.rhs = Double.POSITIVE_INFINITY;
            this.parent = null;
            this.inOpenList = false;
        }
        
        @Override
        public int compareTo(Node other) {
            if (Math.abs(this.key1 - other.key1) > 1e-9) {
                return Double.compare(this.key1, other.key1);
            }
            return Double.compare(this.key2, other.key2);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Node) {
                Node other = (Node) obj;
                return this.x == other.x && this.y == other.y;
            }
            return false;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
    }
    
    private static class Point {
        int x, y;
        
        Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
        
        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Point) {
                Point other = (Point) obj;
                return this.x == other.x && this.y == other.y;
            }
            return false;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
        
        @Override
        public String toString() {
            return "(" + x + ", " + y + ")";
        }
    }
    
    public DStarPathfinder() {
        obstacles = new boolean[GRID_SIZE][GRID_SIZE];
        knownObstacles = new boolean[GRID_SIZE][GRID_SIZE];
        nodes = new Node[GRID_SIZE][GRID_SIZE];
        openList = new PriorityQueue<>();
        closedList = new HashSet<>();
        
        // Initialize nodes
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                nodes[i][j] = new Node(i, j);
            }
        }
    }
    
    /**
     * Set up the environment with obstacle and start/goal positions
     */
    public void setupEnvironment(Point start, Point goal, int obstacleX, int obstacleY, 
                                int obstacleWidth, int obstacleHeight) {
        this.start = start;
        this.goal = goal;
        this.currentPosition = new Point(start.x, start.y);
        
        // Place rectangular obstacle
        for (int i = obstacleX; i < obstacleX + obstacleWidth && i < GRID_SIZE; i++) {
            for (int j = obstacleY; j < obstacleY + obstacleHeight && j < GRID_SIZE; j++) {
                obstacles[i][j] = true;
            }
        }
        
        // Initially, robot might know partial obstacle information
        // For demonstration, assume robot knows 30% of obstacle initially
        Random rand = new Random(42); // Fixed seed for reproducibility
        for (int i = obstacleX; i < obstacleX + obstacleWidth && i < GRID_SIZE; i++) {
            for (int j = obstacleY; j < obstacleY + obstacleHeight && j < GRID_SIZE; j++) {
                if (rand.nextDouble() < 0.3) {
                    knownObstacles[i][j] = true;
                }
            }
        }
    }
    
    /**
     * Calculate heuristic distance (Euclidean)
     */
    private double heuristic(Node node, Point target) {
        return Math.sqrt(Math.pow(node.x - target.x, 2) + Math.pow(node.y - target.y, 2));
    }
    
    /**
     * Calculate key values for priority queue
     */
    private void calculateKey(Node node) {
        double minVal = Math.min(node.g, node.rhs);
        node.key1 = minVal + heuristic(node, currentPosition);
        node.key2 = minVal;
    }
    
    /**
     * Get valid neighbors of a node
     */
    private List<Node> getNeighbors(Node node) {
        List<Node> neighbors = new ArrayList<>();
        int[] dx = {-1, -1, -1, 0, 0, 1, 1, 1};
        int[] dy = {-1, 0, 1, -1, 1, -1, 0, 1};
        
        for (int i = 0; i < 8; i++) {
            int nx = node.x + dx[i];
            int ny = node.y + dy[i];
            
            if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                neighbors.add(nodes[nx][ny]);
            }
        }
        return neighbors;
    }
    
    /**
     * Calculate cost between two adjacent nodes
     */
    private double cost(Node from, Node to) {
        if (knownObstacles[to.x][to.y]) {
            return Double.POSITIVE_INFINITY;
        }
        
        // Diagonal movement costs sqrt(2), orthogonal costs 1
        if (Math.abs(from.x - to.x) + Math.abs(from.y - to.y) == 2) {
            return SQRT2;
        }
        return 1.0;
    }
    
    /**
     * Update vertex in D* algorithm
     */
    private void updateVertex(Node node) {
        if (!node.equals(nodes[goal.x][goal.y])) {
            node.rhs = Double.POSITIVE_INFINITY;
            for (Node neighbor : getNeighbors(node)) {
                double edgeCost = cost(node, neighbor);
                if (edgeCost != Double.POSITIVE_INFINITY) {
                    node.rhs = Math.min(node.rhs, neighbor.g + edgeCost);
                }
            }
        }
        
        if (node.inOpenList) {
            openList.remove(node);
            node.inOpenList = false;
        }
        
        if (Math.abs(node.g - node.rhs) > 1e-9) {
            calculateKey(node);
            openList.add(node);
            node.inOpenList = true;
        }
    }
    
    /**
     * Compute shortest path using D* algorithm
     */
    private void computeShortestPath() {
        while (!openList.isEmpty()) {
            Node current = openList.peek();
            calculateKey(nodes[currentPosition.x][currentPosition.y]);
            
            if (current.compareTo(nodes[currentPosition.x][currentPosition.y]) >= 0 && 
                Math.abs(nodes[currentPosition.x][currentPosition.y].rhs - 
                        nodes[currentPosition.x][currentPosition.y].g) < 1e-9) {
                break;
            }
            
            current = openList.poll();
            current.inOpenList = false;
            
            if (current.g > current.rhs) {
                current.g = current.rhs;
                for (Node neighbor : getNeighbors(current)) {
                    updateVertex(neighbor);
                }
            } else {
                current.g = Double.POSITIVE_INFINITY;
                updateVertex(current);
                for (Node neighbor : getNeighbors(current)) {
                    updateVertex(neighbor);
                }
            }
        }
    }
    
    /**
     * Initialize D* algorithm
     */
    public void initialize() {
        openList.clear();
        closedList.clear();
        
        // Initialize all nodes
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                nodes[i][j].g = Double.POSITIVE_INFINITY;
                nodes[i][j].rhs = Double.POSITIVE_INFINITY;
                nodes[i][j].inOpenList = false;
            }
        }
        
        // Set goal
        nodes[goal.x][goal.y].rhs = 0;
        calculateKey(nodes[goal.x][goal.y]);
        openList.add(nodes[goal.x][goal.y]);
        nodes[goal.x][goal.y].inOpenList = true;
        
        computeShortestPath();
    }
    
    /**
     * Discover new obstacles during movement (sensor simulation)
     */
    private boolean discoverObstacles() {
        boolean newObstacleFound = false;
        int sensorRange = 5; // Robot can detect obstacles within 5 meters
        
        for (int i = Math.max(0, currentPosition.x - sensorRange); 
             i <= Math.min(GRID_SIZE - 1, currentPosition.x + sensorRange); i++) {
            for (int j = Math.max(0, currentPosition.y - sensorRange); 
                 j <= Math.min(GRID_SIZE - 1, currentPosition.y + sensorRange); j++) {
                if (obstacles[i][j] && !knownObstacles[i][j]) {
                    knownObstacles[i][j] = true;
                    newObstacleFound = true;
                    System.out.println("New obstacle discovered at (" + i + ", " + j + ")");
                    
                    // Update affected vertices
                    updateVertex(nodes[i][j]);
                    for (Node neighbor : getNeighbors(nodes[i][j])) {
                        updateVertex(neighbor);
                    }
                }
            }
        }
        
        return newObstacleFound;
    }
    
    /**
     * Find and execute path with dynamic replanning
     */
    public List<Point> findPath() {
        List<Point> fullPath = new ArrayList<>();
        initialize();
        
        System.out.println("Starting D* pathfinding from " + start + " to " + goal);
        fullPath.add(new Point(currentPosition.x, currentPosition.y));
        
        int stepCount = 0;
        while (!currentPosition.equals(goal) && stepCount < GRID_SIZE * 2) {
            stepCount++;
            
            // Check for new obstacles
            boolean newObstacles = discoverObstacles();
            if (newObstacles) {
                System.out.println("Replanning due to new obstacle discovery...");
                computeShortestPath();
            }
            
            // Move to next best cell
            Node currentNode = nodes[currentPosition.x][currentPosition.y];
            if (Math.abs(currentNode.g - Double.POSITIVE_INFINITY) < 1e-9) {
                System.out.println("No path to goal exists!");
                break;
            }
            
            // Find best next move
            Node nextNode = null;
            double minCost = Double.POSITIVE_INFINITY;
            
            for (Node neighbor : getNeighbors(currentNode)) {
                double moveCost = cost(currentNode, neighbor) + neighbor.g;
                if (moveCost < minCost) {
                    minCost = moveCost;
                    nextNode = neighbor;
                }
            }
            
            if (nextNode == null) {
                System.out.println("No valid move available!");
                break;
            }
            
            // Move to next position
            currentPosition.x = nextNode.x;
            currentPosition.y = nextNode.y;
            fullPath.add(new Point(currentPosition.x, currentPosition.y));
            
            if (stepCount % 50 == 0) {
                System.out.println("Step " + stepCount + ": Moved to " + currentPosition);
            }
            
            // Break if we've reached the goal to avoid infinite loop
            if (currentPosition.x == goal.x && currentPosition.y == goal.y) {
                break;
            }
        }
        
        if (currentPosition.x == goal.x && currentPosition.y == goal.y) {
            System.out.println("Goal reached successfully!");
        }
        
        return fullPath;
    }
    
    /**
     * Print a visual representation of the grid and path
     */
    public void printGrid(List<Point> path) {
        // Focus on the obstacle area for better visualization
        int obstacleArea = findObstacleArea();
        int centerX = (obstacleArea != -1) ? 355 : (start.x + goal.x) / 2; // Center around obstacle
        int centerY = (obstacleArea != -1) ? 352 : (start.y + goal.y) / 2;
        
        int minX = Math.max(0, centerX - 25);
        int maxX = Math.min(GRID_SIZE - 1, centerX + 25);
        int minY = Math.max(0, centerY - 15);
        int maxY = Math.min(GRID_SIZE - 1, centerY + 15);
        
        Set<Point> pathSet = new HashSet<>();
        for (Point p : path) {
            pathSet.add(new Point(p.x, p.y));
        }
        
        System.out.println("\nGrid visualization (obstacle area):");
        System.out.println("S = Start, G = Goal, # = Known Obstacle, O = Unknown Obstacle, * = Path, . = Free space");
        System.out.println("Coordinates shown: (" + minX + "," + minY + ") to (" + maxX + "," + maxY + ")");
        
        for (int j = maxY; j >= minY; j--) {
            System.out.printf("%3d ", j);
            for (int i = minX; i <= maxX; i++) {
                char c = '.';
                if (i == start.x && j == start.y) c = 'S';
                else if (i == goal.x && j == goal.y) c = 'G';
                else if (knownObstacles[i][j]) c = '#';
                else if (obstacles[i][j] && !knownObstacles[i][j]) c = 'O'; // Unknown obstacles
                else if (pathSet.contains(new Point(i, j))) c = '*';
                
                System.out.print(c);
            }
            System.out.println();
        }
        
        System.out.print("    ");
        for (int i = minX; i <= maxX; i++) {
            System.out.print(i % 10);
        }
        System.out.println();
        
        // Also print start area
        printAreaAroundPoint("Start Area", start, path, 10);
        // And goal area  
        printAreaAroundPoint("Goal Area", goal, path, 10);
    }
    
    /**
     * Print area around a specific point
     */
    private void printAreaAroundPoint(String title, Point center, List<Point> path, int radius) {
        int minX = Math.max(0, center.x - radius);
        int maxX = Math.min(GRID_SIZE - 1, center.x + radius);
        int minY = Math.max(0, center.y - radius);
        int maxY = Math.min(GRID_SIZE - 1, center.y + radius);
        
        Set<Point> pathSet = new HashSet<>();
        for (Point p : path) {
            pathSet.add(new Point(p.x, p.y));
        }
        
        System.out.println("\n" + title + ":");
        System.out.printf("Coordinates: (%d,%d) to (%d,%d)\n", minX, minY, maxX, maxY);
        
        for (int j = maxY; j >= minY; j--) {
            System.out.printf("%3d ", j);
            for (int i = minX; i <= maxX; i++) {
                char c = '.';
                if (i == start.x && j == start.y) c = 'S';
                else if (i == goal.x && j == goal.y) c = 'G';
                else if (knownObstacles[i][j]) c = '#';
                else if (obstacles[i][j] && !knownObstacles[i][j]) c = 'O';
                else if (pathSet.contains(new Point(i, j))) c = '*';
                
                System.out.print(c);
            }
            System.out.println();
        }
        
        System.out.print("    ");
        for (int i = minX; i <= maxX; i++) {
            System.out.print(i % 10);
        }
        System.out.println();
    }
    
    /**
     * Find if there are any obstacles in the known obstacles array
     */
    private int findObstacleArea() {
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                if (obstacles[i][j]) {
                    return i * GRID_SIZE + j; // Return some indication
                }
            }
        }
        return -1;
    }
    
    /**
     * Print obstacle discovery statistics
     */
    private void printObstacleStats() {
        int totalObstacles = 0;
        int knownObstaclesCount = 0;
        
        for (int i = 0; i < GRID_SIZE; i++) {
            for (int j = 0; j < GRID_SIZE; j++) {
                if (obstacles[i][j]) {
                    totalObstacles++;
                    if (knownObstacles[i][j]) {
                        knownObstaclesCount++;
                    }
                }
            }
        }
        
        System.out.println("\nObstacle Discovery Statistics:");
        System.out.println("Total obstacle cells: " + totalObstacles);
        System.out.println("Known obstacle cells: " + knownObstaclesCount);
        System.out.println("Discovery percentage: " + 
            String.format("%.1f", (knownObstaclesCount * 100.0 / totalObstacles)) + "%");
    }
    
    /**
     * Main method for testing
     */
    public static void main(String[] args) {
        DStarPathfinder pathfinder = new DStarPathfinder();
        
        // Setup scenario: robot starts at (100,100), goal at (600,600)
        // Obstacle: 10m x 5m rectangle at (350, 350) - closer to path
        Point start = new Point(100, 100);
        Point goal = new Point(600, 600);
        
        pathfinder.setupEnvironment(start, goal, 350, 350, 10, 5);
        
        System.out.println("D* Pathfinding Algorithm Demo");
        System.out.println("Grid size: " + GRID_SIZE + "x" + GRID_SIZE + " (1km x 1km)");
        System.out.println("Start: " + start);
        System.out.println("Goal: " + goal);
        System.out.println("Obstacle: 10x5 rectangle at (350, 350)");
        System.out.println("Robot initially knows ~30% of obstacle locations");
        
        long startTime = System.currentTimeMillis();
        List<Point> path = pathfinder.findPath();
        long endTime = System.currentTimeMillis();
        
        System.out.println("\nPathfinding completed in " + (endTime - startTime) + " ms");
        System.out.println("Path length: " + path.size() + " steps");
        
        if (!path.isEmpty()) {
            System.out.println("First few path points:");
            for (int i = 0; i < Math.min(10, path.size()); i++) {
                System.out.println("  " + i + ": " + path.get(i));
            }
            
            if (path.size() > 10) {
                System.out.println("  ...");
                for (int i = Math.max(10, path.size() - 5); i < path.size(); i++) {
                    System.out.println("  " + i + ": " + path.get(i));
                }
            }
            
            // Calculate total distance
            double totalDistance = 0;
            for (int i = 1; i < path.size(); i++) {
                Point p1 = path.get(i-1);
                Point p2 = path.get(i);
                totalDistance += Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            }
            System.out.println("Total path distance: " + String.format("%.2f", totalDistance) + " meters");
        }
        
        pathfinder.printGrid(path);
        
        // Print obstacle discovery statistics
        pathfinder.printObstacleStats();
    
    }
}
